<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="true" > 
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  

  
  <title>[C/Cpp]在C中的Cpp | MongXin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="preload" href="/css/fonts/Roboto-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
  <link rel="preload" href="/css/fonts/Roboto-Bold.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <meta name="description" content="Since C++ is based on C, you must be familiar with the  syntax of C in order to program in C++, just as you  must be reasonably fluent in algebra in order to tackle  calculus. C++是以C为基础的，所以要用C++编程时候，">
<meta property="og:type" content="article">
<meta property="og:title" content="[C&#x2F;Cpp]在C中的Cpp">
<meta property="og:url" content="http://example.com/2024/09/13/[CCpp]%E5%9C%A8C%E4%B8%AD%E7%9A%84Cpp/index.html">
<meta property="og:site_name" content="MongXin&#39;s Blog">
<meta property="og:description" content="Since C++ is based on C, you must be familiar with the  syntax of C in order to program in C++, just as you  must be reasonably fluent in algebra in order to tackle  calculus. C++是以C为基础的，所以要用C++编程时候，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i-blog.csdnimg.cn/blog_migrate/f76d00ea72fe6348c3399c4f3a4e3f0f.png">
<meta property="article:published_time" content="2024-09-13T15:18:17.871Z">
<meta property="article:modified_time" content="2024-10-24T09:31:18.182Z">
<meta property="article:author" content="MongXin">
<meta property="article:tag" content="运行逻辑">
<meta property="article:tag" content="C&#x2F;Cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i-blog.csdnimg.cn/blog_migrate/f76d00ea72fe6348c3399c4f3a4e3f0f.png">
  
    <link rel="alternate" href="/atom.xml" title="MongXin's Blog" type="application/atom+xml">
  
  
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-192.png" sizes="192x192">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-192.png" sizes="192x192">
    <link rel="stylesheet" href="blog\node_modules\Typro-theme-YuanShan-master\assets\yuan-shan.css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>
  
  
    
<div id="banner" class="">
  <img src="/images/Banner.jpg" itemprop="image">
  <div id="banner-dim"></div>
</div>
 
   
  <div id="main-grid" class="  ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>MongXin's Blog </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">首页</a>
    
      <a class="main-nav-link" href="/archives">归档</a>
    
      <a class="main-nav-link" href="/music">音乐</a>
    
      <a class="main-nav-link" href="/movie">电影</a>
    
      <a class="main-nav-link" href="/notes">随笔</a>
    
      <a class="main-nav-link" href="/linking">友链</a>
    
      <a class="main-nav-link" href="/about">关于</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="light-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M438.5-829.913v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-829.913Zm0 747.826v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-82.087ZM877.913-438.5h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537t29.476-12.174h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T877.913-438.5Zm-747.826 0h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T82.087-521.5h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T130.087-438.5Zm660.174-290.87-34.239 32q-12.913 12.674-29.565 12.174-16.653-.5-29.327-13.174-12.674-12.673-12.554-28.826.12-16.152 12.794-28.826l33-35q12.913-12.674 30.454-12.674t30.163 12.847q12.709 12.846 12.328 30.826-.38 17.98-13.054 30.653ZM262.63-203.978l-32 34q-12.913 12.674-30.454 12.674t-30.163-12.847q-12.709-12.846-12.328-30.826.38-17.98 13.054-30.653l33.239-31q12.913-12.674 29.565-12.174 16.653.5 29.327 13.174 12.674 12.673 12.554 28.826-.12 16.152-12.794 28.826Zm466.74 33.239-32-33.239q-12.674-12.913-12.174-29.565.5-16.653 13.174-29.327 12.673-12.674 28.826-13.054 16.152-.38 28.826 12.294l35 33q12.674 12.913 12.674 30.454t-12.847 30.163q-12.846 12.709-30.826 12.328-17.98-.38-30.653-13.054ZM203.978-697.37l-34-33q-12.674-12.913-13.174-29.945-.5-17.033 12.174-29.707t31.326-13.293q18.653-.62 31.326 13.054l32 34.239q11.674 12.913 11.174 29.565-.5 16.653-13.174 29.327-12.673 12.674-28.826 12.554-16.152-.12-28.826-12.794ZM480-240q-100 0-170-70t-70-170q0-100 70-170t170-70q100 0 170 70t70 170q0 100-70 170t-170 70Zm-.247-82q65.703 0 111.475-46.272Q637-414.544 637-480.247t-45.525-111.228Q545.95-637 480.247-637t-111.475 45.525Q323-545.95 323-480.247t45.525 111.975Q414.05-322 479.753-322ZM481-481Z"/></svg></span>
      <span class="dark-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M480.239-116.413q-152.63 0-258.228-105.478Q116.413-327.37 116.413-480q0-130.935 77.739-227.435t206.304-125.043q43.022-9.631 63.87 10.869t3.478 62.805q-8.891 22.043-14.315 44.463-5.424 22.42-5.424 46.689 0 91.694 64.326 155.879 64.325 64.186 156.218 64.186 24.369 0 46.978-4.946 22.609-4.945 44.413-14.076 42.826-17.369 62.967 1.142 20.142 18.511 10.511 61.054Q807.174-280 712.63-198.206q-94.543 81.793-232.391 81.793Zm0-95q79.783 0 143.337-40.217 63.554-40.218 95.793-108.283-15.608 4.044-31.097 5.326-15.49 1.283-31.859.805-123.706-4.066-210.777-90.539-87.071-86.473-91.614-212.092-.24-16.369.923-31.978 1.164-15.609 5.446-30.978-67.826 32.478-108.282 96.152Q211.652-559.543 211.652-480q0 111.929 78.329 190.258 78.329 78.329 190.258 78.329ZM466.13-465.891Z"/></svg></span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/atom.xml" title="RSS 订阅">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M198-120q-25.846 0-44.23-18.384-18.384-18.385-18.384-44.23 0-25.846 18.384-44.23 18.384-18.385 44.23-18.385 25.846 0 44.23 18.385 18.384 18.384 18.384 44.23 0 25.845-18.384 44.23Q223.846-120 198-120Zm538.385 0q-18.846 0-32.923-13.769-14.076-13.769-15.922-33.23-8.692-100.616-51.077-188.654-42.385-88.039-109.885-155.539-67.5-67.501-155.539-109.885Q283-663.462 182.385-672.154q-19.461-1.846-33.23-16.23-13.769-14.385-13.769-33.846t14.076-32.922q14.077-13.461 32.923-12.23 120.076 8.692 226.038 58.768 105.961 50.077 185.73 129.846 79.769 79.769 129.846 185.731 50.077 105.961 58.769 226.038 1.231 18.846-12.538 32.922Q756.461-120 736.385-120Zm-252 0q-18.231 0-32.423-13.461t-18.653-33.538Q418.155-264.23 348.886-333.5q-69.27-69.27-166.501-84.423-20.077-4.462-33.538-18.961-13.461-14.5-13.461-33.346 0-19.076 13.884-33.23 13.884-14.153 33.115-10.922 136.769 15.384 234.384 112.999 97.615 97.615 112.999 234.384 3.231 19.23-10.538 33.115Q505.461-120 484.385-120Z"/></svg>
      </a>
    
    <div id="nav-menu-btn" class="nav-icon">
      <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M177.37-252.282q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Zm0-186.218q-17.453 0-29.477-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T177.37-521.5h605.26q17.453 0 29.477 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T782.63-438.5H177.37Zm0-186.217q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Z"/></svg>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">首页</a>
    
      <a class="nav-dropdown-link" href="/archives">归档</a>
    
      <a class="nav-dropdown-link" href="/music">音乐</a>
    
      <a class="nav-dropdown-link" href="/movie">电影</a>
    
      <a class="nav-dropdown-link" href="/notes">随笔</a>
    
      <a class="nav-dropdown-link" href="/linking">友链</a>
    
      <a class="nav-dropdown-link" href="/about">关于</a>
    
    
      <a class="nav-dropdown-link" href="/atom.xml" title="RSS 订阅">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=/%5Bobject%20Object%5D></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">Mongxin Chan </div>
      <div class="dot"></div>
      <div class="subtitle">这里就是罗德岛，要跳就在这里跳 </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://steamcommunity.com/id/MongXin_Chan" title="Steam"><i class="fa-brands fa-steam"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/MongXinChan" title="GitHub"><i class="fa-brands fa-github"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      


  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">分类</h3>
      <div class="category-box">
            <a class="category-link" href="/categories/%E8%AF%AD%E6%B3%95/">
                语法
                <div class="category-count">5</div>
            </a>
        
            <a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                数据结构
                <div class="category-count">5</div>
            </a>
        
            <a class="category-link" href="/categories/%E7%AB%9E%E8%B5%9B/">
                竞赛
                <div class="category-count">1</div>
            </a>
        </div>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">标签</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/C-Cpp/" rel="tag">C&#x2F;Cpp</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E4%BF%A1%E6%81%AF%E5%AD%A6/" rel="tag">信息学</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%AB%9E%E8%B5%9B/" rel="tag">竞赛</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91/" rel="tag">运行逻辑</a></li></ul>
    </div>
  </div>


    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       


<article id="post-[CCpp]在C中的Cpp" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        [C/Cpp]在C中的Cpp
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2024-09-13T15:18:17.871Z" itemprop="datePublished">2024-09-13</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
  <a class="meta-cate-link" href="/categories/%E8%AF%AD%E6%B3%95/">语法</a>
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            9.4k 词 
          </div>
        </div>
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-Cpp/" rel="tag">C&#x2F;Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91/" rel="tag">运行逻辑</a></li></ul>

      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <blockquote>
<p>Since C++ is based on C, you must be familiar with the  syntax of C in order to program in C++, just as you  must be reasonably fluent in algebra in order to tackle  calculus.</p>
<p>C++是以C为基础的，所以要用C++编程时候，就必须要熟悉C的语法，就像要解决微积分必须对代数十分了解一样。</p>
<p>——Thinking in C++</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于我们对<code>Cpp</code>的框架还不够了解，在此我这一篇章进行对<code>Cpp</code>语法的拆分（没错，这个<code>Cpp</code>的坑也算是填起来了），<code>Cpp</code>对于学过<code>C</code>的人来说好像似曾相识，两种差别并不是很多，但是为何<code>Cpp</code>有了如此高效的效率？<code>Cpp</code>对<code>C</code>的特征进行了一些修改，<code>Cpp</code>更为复杂的特性将会在后面中介绍。</p>
<p>[TOC]</p>
<h2 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h2><p><code>标准C</code>和<code>Cpp</code>有一个特征叫做函数原型(function prototyping ).用函数原型，在声明和定义一个函数时，必须使用变量类型描述，也称为“原型”。调用函数时，编译器使用原形确保正确传递变量并且正确地处理返回值。</p>
<p><code>Cpp</code>中函数声明的形式需要正确的原形。在函数原形中，参数表包含了应当传给函数类型的参数和表示符。变量的顺序和数据类型必须在声明、定义和函数调用中相匹配。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">translate</span><span class="params">(<span class="type">float</span> x,<span class="type">float</span> y,<span class="type">float</span> z)</span></span>;</span><br></pre></td></tr></table></figure>

<p>而在<strong>函数声明</strong>中，<strong>必须要声明每一种变量的类型，但是其参数名称可以省略掉</strong>。这是由于调用函数时，编译器只是检测类型，所以使用标识符只是为了使别人阅读代码时更加清晰。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">translate</span><span class="params">(<span class="type">float</span>,<span class="type">float</span>,<span class="type">float</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在函数定义中，因为变量是在函数内部引用的，所以需要命名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">translate</span><span class="params">(<span class="type">float</span> x,<span class="type">float</span> y,<span class="type">float</span> z)</span></span>&#123;</span><br><span class="line">    x=y;</span><br><span class="line">    y=z;</span><br><span class="line">    <span class="comment">//context;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得一提的是，这条规则只应用于<code>C</code>。<code>Cpp</code>中，<strong>函数定义的参数表中可以使用的未命名的参数</strong>。当然，因为它没有被命名，所以不能在函数体中使用它。允许不命名参数是为了给程序员提供“在参数列表中保留位置”的一种方式。不管谁调用函数函数都必须使用正确的参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">translate</span><span class="params">(<span class="type">float</span> x,<span class="type">float</span> y,<span class="type">float</span> z)</span></span>&#123;</span><br><span class="line">    x=y;</span><br><span class="line">&#125;<span class="comment">//在Cpp中会显示警告异常，当我们删去的时候就不会有这个alert.</span></span><br></pre></td></tr></table></figure>

<p>即使给出命名，在参数表中忽略这个参数也是可能的，但每次编译函数的时候，会得到<u>这个数值没有被使用这样一条令人讨厌的警告消息</u>。<strong>如果删去这个变量，这个警告也会随之消除</strong>。</p>
<p>在我们编程的时候也会有如下的问题：</p>
<blockquote>
<p>我们不知道会有多少个变量，并且也不知道其数据类型，应该怎么办？</p>
</blockquote>
<p>参数表的另一种选择是可变的参数列表。这个”不确定参数列表”用省略号(…)表示。定义一个带可变参数列表的函数比定义一个带固定参数列表的函数复杂得多。<strong>因为你还需要对参数的数据进行操作，而不像有固定参数来得简单</strong>。</p>
<p><code>Cpp</code>是一种<strong>缺省的语言</strong>，给出所有参数的称之为<strong>全缺省参数</strong>，只有部分参数给出缺省参数的称之为<strong>半缺省参数</strong>，而缺省参数只能从右往左，依次给出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c=<span class="number">10</span>)</span></span>;<span class="comment">//OK</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b=<span class="number">10</span>,<span class="type">int</span> c=<span class="number">20</span>)</span></span>;<span class="comment">//OK</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b=<span class="number">10</span>,<span class="type">int</span> c)</span></span>;<span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>

<h2 id="使用C的函数库"><a href="#使用C的函数库" class="headerlink" title="使用C的函数库"></a>使用C的函数库</h2><p>使用<code>Cpp</code>变成时，当<code>C</code>函数库中的所有函数都可以使用。在定义自己的函数之前，应该仔细地看一下函数库，我们可以根据现有的函数来解决问题，<strong>而且这些函数可以给予我们更多的思考和调试技巧。</strong></p>
<p>尽管编译器包含了大量的额外函数，使得我们解决编程问题更加简单，但这并不是标准<code>C</code>库的一部分。如果我们想让程序具有<strong>可移植性</strong>，我们应用这些外部的函数应该杜绝，只使用标准库函数。<code>Cpp</code>中，经常把特定平台的活动封装在一个类中，这是一个理想的解决可移植性的方法。</p>
<p>我曾在之前的文章中写：</p>
<blockquote>
<p>​	我们注意到，实际上<code>#include&lt;stdio.h&gt;</code>和<code>#include&lt;iostream&gt;</code>本质上就是封装了许许多多代码段综合而成的，编译后产生的是许多行<code>stdio.h</code>和<code>iostream</code>所包含的代码；<br>​	而我们将这种使用一个“<strong>压缩包</strong>”把许多段代码段封装的“<strong>压缩包</strong>”称为<strong>函数</strong>，而<code>#include&lt;&gt;</code>是函数的一种，我们称之为<strong>库函数</strong>。</p>
</blockquote>
<p>但是现在我们要进行重新转述：</p>
<blockquote>
<p>首先，在<code>Cpp</code>手册&#x2F;文档中查找函数，函数的描述应该包括说明代码语法的部分。</p>
<p>其次，连接器通过默认路径查找标准库，所以在变成需要做的就是<strong>包含这个头文件</strong>和<strong>调用这个函数</strong>。</p>
</blockquote>
<h3 id="通过库管理创建自己的库"><a href="#通过库管理创建自己的库" class="headerlink" title="通过库管理创建自己的库"></a>通过库管理创建自己的库</h3><p>我们可以将自定义的函数收集到一个库中，这跟我们在<code>C</code>中介绍的<code>#include&lt;stdio.h&gt;</code>一样，由于我们先行定义了输入输出，我们才有<code>scanf();printf();</code>而当我们把目光放在一个大的体系框架中，我们会发现现有的某些函数并不能帮助我们实现想要的功能，这个时候我们就把目光放在自建库中。</p>
<p>关于这些自定义的头文件，我们用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;FunctionName.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>来标记，其中<code>&quot;&quot;</code>是必须的，表示本地中存在的函数库。我们把通过所有对象模块联通建成后的库名传递给库管理器(大多数管理器要求有一个共同的扩展名，例如<code>.lib</code>或者<code>.a</code>)。把建成的库和其他的库放在同一个位置(也就是放在同一个<code>.cpp</code>里，方便我们观察)，方便Linking进行连接。当使用自己的库时，必须向命令行里添加一些东西，让其他Linking知道为你调用的函数查找库。因为函数库在每个系统中都迥异，在这里推荐阅读同一系统手册的内容，查找所有的细节。</p>
<h2 id="执行控制语句"><a href="#执行控制语句" class="headerlink" title="执行控制语句"></a>执行控制语句</h2><p>实际上这个东西前面我讲过，<code>Cpp</code>涵盖了一切<code>C</code>的所有执行控制语句。这些语句包括<strong>if-else、while、do-while、for</strong>和<strong>switch</strong>。自然也包括声名狼藉的<code>goto</code>语句。</p>
<p>我们可以通过运算符条件判断是否为真(<strong>非零</strong>)，也就是诸如<code>==</code>,<code>&gt;=</code>,<code>&lt;=</code>,<code>!=</code>,<code>&lt;</code>,<code>&gt;</code>,<code>?:</code>。表达式计算后产生布尔值，假设通过<code>==</code>，我们判断变量A是否等于变量B。**表达式产生布尔值true(真，或者非0)或布尔值false(假，0)**。</p>
<p>在这里我们省去这些的篇章，着重点在于<code>break和continue的差距</code>，<code>goto</code>语句。</p>
<blockquote>
<p>continue是直接结束本次循环，而<strong>继续</strong>进行循环体的重复应用。</p>
<p>break则是结束本次循环，并<strong>关闭</strong>这个循环体。</p>
</blockquote>
<p>而因为关键字<code>goto</code>存在于<code>C</code>中，所以<code>Cpp</code>中也支持它。<code>goto</code>是一种不好的编程方式，经常避免使用<code>goto</code>。在多数情况下的确如此。想使用<code>goto</code>语句时，查一下程序代码，看是否有其他的解决方法。在少数情况下，可能会发现<code>goto</code>语句能够解决用别的方法不能解决的问题，但是尽管如此，还应仔细考虑一下。下面是一个例子，可能会作出似乎有理的选择:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//The infamous goto is supported in C++</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> val=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt; <span class="number">1000</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(intj=<span class="number">1</span>;j&lt;<span class="number">100</span>;j+= <span class="number">10</span>)&#123;</span><br><span class="line">            val =i * j;</span><br><span class="line">                <span class="keyword">if</span>(val &gt; <span class="number">47000</span>)</span><br><span class="line">                    <span class="keyword">goto</span> bottom;<span class="comment">//Break would only go to the outer &#x27;for</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bottom:<span class="comment">//Alabel</span></span><br><span class="line">    cout &lt;&lt; val&lt;&lt; endl;</span><br><span class="line">&#125;<span class="comment">///:~</span></span><br><span class="line"><span class="comment">//from Thinking in Cpp</span></span><br></pre></td></tr></table></figure>

<h2 id="数据类型简介"><a href="#数据类型简介" class="headerlink" title="数据类型简介"></a>数据类型简介</h2><p>数据类型(datatype)<strong>定义使用存储空间</strong>(内存)的方式。</p>
<p>通过定义数据类型，告诉编译器怎样创建一片特定的存储空间，以及怎样操纵这片<strong>存储空间</strong>。数据类型可以是<strong>内部的</strong>或<strong>抽象的</strong>。内部数据类型是编译器本来能理解的数据类型，直接与编译器关联。<code>C</code>和<code>Cpp</code>中的内部数据类型几乎是一样的。相反，用户定义的数据类型是我们和别的程序员创建的类型，作为一个类。它们一般被称为抽象数据类型。</p>
<p>编译器启动时，知道怎样处理内部数据类型:编译器再通过读包含类声明的<strong>头文件</strong>认识如何处理抽象数据类型。</p>
<h3 id="基本内部类型"><a href="#基本内部类型" class="headerlink" title="基本内部类型"></a>基本内部类型</h3><p>标准C的内部类型(<strong>由<code>Cpp</code>继承</strong>)规范不说明每一个内部类型必须有多少位。规范只规定内部类型必须能存储的最大值和最小值。如果机器基于二进制，则最大值可以直接转换成容纳这个值所需的最少位数。然而，例如，如果一个机器使用二进制编码的十进制(BCD)来表示数字，在机器中容纳每一种数据类型的最大数值的空间是不同的。系统头文件<code>limits.h</code>和<code>float.h</code>中定义了不同的数据类型可能存储的最大值和最小值(在C++中，一般用<code>#include&lt;climits&gt;</code>和<code>&lt;cfloat&gt;</code>代替).</p>
<p><code>C</code>和<code>Cpp</code>中有4个基本的内部数据类型，这里的描述是基于二进制的机器。<code>char</code>是用于存储字符的，使用最小的8位(一个字节)的存储，尽管它可能占用更大的空间。<code>int</code>存储整数值，使用最小两个字节的存储空间。<code>float</code>和<code>double</code>类型存储浮点数，一般使用<code>IEEE</code>的浮点格式。<code>float</code>用于单精度浮点数，<code>double</code>用于双精度浮点数。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f76d00ea72fe6348c3399c4f3a4e3f0f.png" alt="img"></p>
<p>值得一提的是，<code>static</code>、<code>extern</code>可以提及一嘴：</p>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>关键字<code>static</code>有一些独特的意义。通常，函数中定义的<strong>局部变量</strong>会在函数作用域消失时消失。再次调用这个函数时，会重新创建该变量的存储空间，也就是说会<strong>反复初始化</strong>。当我们用<code>static</code>定义函数的局部变量，<strong>并且给其赋值</strong>。其<strong>初始化仅在第一次调用时执行</strong>，函数调用之间的变量的值保持不变。用这种方法，函数可以“记忆”(memory)函数调用之间的一些信息片段。</p>
<p><code>static</code>的有点是在函数范围之外它是不可用的，所以它除了在其函数中会被改变外，不会轻易地被改变，这样会导致错误局部化。</p>
<p><code>static</code>的第二层意思和前面的含义相关，即<strong>“在某个作用域外不可访问”</strong>。当应用<code>static</code>于函数名和所有函数外部的变量时，**”它的意思是“在文件的外部不可以使用这个名字”<strong>。函数名或变量是局部于文件的;我们说它具有</strong>文件作用域(lescope)<strong>。例如，编译和连接下面两个文件</strong>会引起连接器错误**:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//:C03:Filestatic.cpp</span></span><br><span class="line"><span class="comment">// File scope demonstration.Compiling and</span></span><br><span class="line"><span class="comment">// linking this file with Filestatic2.cpp</span></span><br><span class="line"><span class="comment">// will cause a linker error</span></span><br><span class="line"><span class="comment">// File scope means only available in this file:</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fs=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//并不能被赋值</span></span><br><span class="line">&#125;<span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p>尽管在下面的文件中变量fs被声明为<code>extern</code>，但是连接器不会找到它，因为在<code>FileStatic.cpp</code>中它被声明为<code>static</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//:C03:FileStatic2.cpp</span></span><br><span class="line"><span class="comment">//Trying to reference fs</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> fs;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fs=<span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>static</code>说明符也可能在一个类中使用。我们会在后面对类的讲解中进行解释</p>
<h4 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h4><p>它告诉编译器存在着一个变量和函数，即使编译器在当前编译的文件中没有看到它。这个变量或函数可能在另一个文件中或者在当前文件的后面定义。下面是一个例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//:C03:Forward.cpp</span></span><br><span class="line"><span class="comment">// Forward function&amp; data declarations</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std:</span><br><span class="line"><span class="comment">// This is not actually external,but the</span></span><br><span class="line"><span class="comment">//compiler must be told it exists somewhere:</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line">	<span class="type">int</span> i;<span class="comment">// The data definitionvoid </span></span><br><span class="line"><span class="built_in">func</span>()&#123;</span><br><span class="line">    i++;</span><br><span class="line">    cout &lt;&lt; i；</span><br><span class="line">&#125;<span class="comment">///:~</span></span><br></pre></td></tr></table></figure>


<p>当编译器遇到<code>extern int i</code>’时，它知道<code>i</code>肯定作为全局变量存在于某处。当编译器看到变量i的定义时，并没有看到别的声明，所以知道它在文件的前面已经找到了同样声明的i。如果已经把变量i定义为static，又要告诉编译器，<code>i</code>是全局定义的(通过extern)，但是，它也有文件作用域(通过<code>static</code>)，所以编译器会产生错误。</p>
<h3 id="转换运算符"><a href="#转换运算符" class="headerlink" title="转换运算符"></a>转换运算符</h3><p><strong>转换(cast)<strong>这个词通常意为</strong>“浇铸成一个模型”</strong>。如果编译器能够明白的话，<strong>它会自动把一种数据类型转换为另一种类型</strong>。例如，如果赋一个整型值给一个浮点变量，编译器会暗地里调用一个函数(或更可能插入代码)来把整型转换为浮点型。<strong>转换允许使用这种显式类型变换，或在转换没有正常情况下发生时强制它实现。</strong></p>
<p>为了实现转换，要用括号把所想要转换的数据类型(包括所有的修饰符)括起来放在值的左边。这个值可以是一个变量、一个常量、由一个表达式产生的值或是一个函数的返回值。下面是一个例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//:C03:SimpleCast.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">200</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> a=(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<p>转换是很有用的，但是它也造成了令人头痛的事，因为在某些情况下，它强制编译器把一个数据看做是比它实际上更大的类型，所以它占用了更多的内存空间，这可能会破坏其他数据。这种情况经常不是出现在上述简单的类型转换时，而在转换指针时发生。</p>
<p><code>Cpp</code>有一个另外的转换语法，它遵从函数调用的语法。这个语法给参数加上括号而不是给数据类型加上括号，类似于函数调用:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//:C03:FunctionCallCast.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">float</span> a=<span class="built_in">float</span>(<span class="number">200</span>);</span><br><span class="line">	<span class="comment">//这相当于</span></span><br><span class="line"> 	<span class="type">float</span> p=(<span class="type">float</span>)<span class="number">200</span>;</span><br><span class="line">)<span class="comment">///:</span></span><br></pre></td></tr></table></figure>


<p>当然对于上面的情况，我们实际上不需要转换，只要写<strong>200f</strong>(实际上，一般编译器会对上面的表达式作转换)。转换一般用于变量，而不用于常量。</p>
<h3 id="Cpp的显式转换"><a href="#Cpp的显式转换" class="headerlink" title="Cpp的显式转换"></a>Cpp的显式转换</h3><p>应该小心使用转换，因为转换实际上要做的就是对编译器说“忘记类型检查，把它看做是其他类型。”这也就是说，在<code>Cpp</code>类型系统中引入了一个<strong>漏洞</strong>，并阻止编译器报告在类型方面出错了。更为糟糕的是，编译器会相信它，而不执行任何其他的检查来捕获错误。一旦开始进行转换，程序员必须自己面对各种问题。<strong>事实上，无论什么原因，任何一个程序如果使用很多转换都值得怀疑。一般情况下，很少使用转换，它只是用于解决非常特殊的问题。</strong></p>
<p>一旦理解了这一点，在遇上一个出故障的程序时，第一个反应应该是寻找作为嫌犯的转换。但是怎样确定C风格转换的位置呢?它们只是在括号中的类型名字，如果开始查找这些的话，我们会发现很难把它们和代码的其他部分区分开来。</p>
<p>标准<code>Cpp</code>包括一个显式的转换语法，使用它来完全替代旧的C风格的转换(当然，如果不破坏代码，是不会认为C风格的转换不合法，但是编译器的编写者很容易标出旧风格的转换)。显式类型转换语法使我们很容易发现它们，因为通过它们的名字就能找到:</p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>static</td>
<td>用于“良性”和“适度良性”转换，包括不用强制转换(例如自动类型转换)</td>
</tr>
<tr>
<td>const_cast</td>
<td>对“const”和&#x2F;或“volatile”进行转换</td>
</tr>
<tr>
<td>reinterpret _cast</td>
<td>转换为完全不同的意思。为了安全使用它，关键必须转换回原来的类型。转换成的类型一般只能用于位操作，否则就是为了其他隐秘的目的。这是所有转换中最危险的</td>
</tr>
<tr>
<td>dynamic_cast</td>
<td>用于类型安全的向下转换</td>
</tr>
</tbody></table>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>在旧版本(标准前)的C中，如果想建立一个常量，必须使用预处理器:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br></pre></td></tr></table></figure>

<p>无论在何地使用PI，都会被预处理器用值3.14159代替(在C和C++中都可以使用这个方法)。</p>
<p>当使用预处理器创建常量时，我们在编译器的范围之外能控制这些常量。对名字P上不进行类型检查，也不能得到PI的地址(所以不能向PI传递一个指针和一个引用)。PI不能是用户定义的类型变量。PI的意义是从定义它的地方持续到文件结束的地方;预处理器并不识别作用域。</p>
<p><code>Cpp</code>引人了命名常量的概念，命名常量就像变量一样，只是它的值不能改变。修饰符<code>const</code>告诉编译器这个名字表示常量。不管是内部的还是用户定义的数据类型都可以定义为<code>const</code>。如果定义了某对象为常量，然后试图修改它，编译器将会产生错误。必须用下述方式说明一个常量类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>在标准C和C++中，可以在参数列表中使用命名常量，即使列表中的参数是指针或引用(也就是说，可以获得<code>const</code>的地址)。<code>const</code>就像正常的变量一样有作用域，所以可以在函数中“隐藏”一个<code>const</code>，确保名字不会影响程序的其余部分。<code>const</code>由<code>Cpp</code>采用，并加进标准<code>C</code>中，尽管它们很不一样。在<code>C</code>中，编译器对待<code>const</code>如同变量一样，只不过带有一个特殊的标记，意思是<strong>“不要改变我”</strong>。当在<code>C</code>中定义<code>const</code>时，编译器为它创建存储空间，所以如果在两个不同的文件中(或在头文件中)定义多个同名的<code>const</code>，连接器将生成发生冲突的错误消息。在<code>C</code>中使用<code>const</code>和在<code>Cpp</code>中使用<code>const</code>是完全不一样的(简而言之，在<code>Cpp</code>中使用得更好)。</p>
<h4 id="常量值"><a href="#常量值" class="headerlink" title="常量值"></a>常量值</h4><p>在<code>Cpp</code>中，一个<code>const</code>必须有初始值(在C中不是这样)。内部类型的常量值可以表示为十进制、八进制、十六进制、浮点数(不幸的是，二进制数被认为是不重要的)或字符。</p>
<p>如果没有其他的线索，编译器会认为常量值是十进制。数值47、0和1101都被认为是十进制数。<br>常量值前带0被认为是八进制数(基数为8)。基数为8的数值只能含有数字0~7;编译器标记其他数字为错误。017是一个合法的八进制数(相当于基数为10的数值15)。</p>
<p>常量值前带0x被认为是十六进制数(基数为16)。基数为16的数值只能含有数字0<del>9和字母a</del>f或A~F。0xlfe是一个合法十六进制数(相当于基数为10的数值510)。</p>
<p>浮点数可以含有小数点和指数幂(用e表示，意思是“10的幂”)。小数点和e都可以任选如果给一个浮点变量赋一个常量值，编译器会取得这个常量值并把它转换为浮点数(这个过程是***隐式类型转换(implicit type conversion)***的一种形式)。但是，使用小数点或e对于提醒读者当前正在使用的是浮点数是一个好主意;一些更旧的编译器也会需要这种暗示。</p>
<p>合法的浮点常量值包括:1e4、1.0001、47.0、0.0和-1.159e-77。***<u>我们可以对数加后缀加浮点数类型</u><em>:f或F强加float型，L或I强加long double型，否则是double型。</em>*</p>
<p>字符常量是用单引号括起来的字符，如’A’、‘0’、‘ ’。注意字符’0’(ASCII 96)和数值0之间存在巨大差别。用“反斜线”表示一些特殊的字符:’\n’(换行)，’\t’(制表符)，’\\’(反斜线)，”\r”(回车)，”’(双引号)，’’\’’ (单引号)，等等。也可以用八进制表示字符常量(如’\17’)或用十六进制表示字符常量(如’\xff’)。</p>
<h3 id="volatile变量"><a href="#volatile变量" class="headerlink" title="volatile变量"></a>volatile变量</h3><p>限定词<code>const</code>告诉编译器<strong>“这是不会改变的”</strong>(这就允许编译器执行额外的优化);而限定词<code>volatile</code>则告诉编译器<strong>“不知道何时会改变”</strong>，防止编译器依据变量的稳定性作任何优化。当读在代码控制之外的某个值时，例如读一块通信硬件中的寄存器，将使用这个关键字。<strong>无论何时需要volatile变量的值，都能读到，即使在该行之前刚刚读过。</strong></p>
<p>“在代码的控制之外”的某个存储空间的一个特殊例子是在多线程程序中。如果正在观察被另一个线程或进程修改的特殊标识符，这个标识符应该是<code>volatile</code>的，所以编译器不会认为它能够对标识符的多次读入进行优化。</p>
<p>注意当编译器不进行优化时，<code>volatile</code>可能不起作用，但是当开始优化代码时(当编译器开始寻找冗余的读入时)，可以防止出现重大的错误。</p>
<h2 id="sizeof——独立运算符"><a href="#sizeof——独立运算符" class="headerlink" title="sizeof——独立运算符"></a>sizeof——独立运算符</h2><p><code>sizeof</code>单独作为一个运算符是因为它满足不同寻常的需要。<code>sizeof</code>给我们提供对有关数据项目所分配的内存大小。正如在本章前面叙述的那样，<code>sizeof</code>告诉我们任何变量使用的字节数。它也可以给出数据类型的大小(不用变量名)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//:C03:sizeof.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;sizeof(double)=&quot;</span>&lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(char)=&quot;</span>&lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">&#125;<span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<p>按照定义，<strong>任何char(signed、unsigned或普通的)类型的sizeof都是1，不管char潜在的存储空间是否实际上是一个字节。</strong>对于所有别的类型，结果都是以字节表示的大小。注意sizeof是一个运算符，不是函数。如果把它应用于一个类型，必须要像上面所示的那样使用括号，但是如果对一个变量使用它，可以不要括号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//:C03:sizeofoperator.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> xi</span><br><span class="line">    <span class="type">int</span> i= <span class="keyword">sizeof</span> x;</span><br><span class="line">&#125;<span class="comment">///:~</span></span><br></pre></td></tr></table></figure>

<p><strong>sizeof也可以给出用户定义的数据类型的大小。</strong></p>
<h2 id="asm关键字"><a href="#asm关键字" class="headerlink" title="asm关键字"></a>asm关键字</h2><p>这是一种转义(escape)机制，允许在<code>Cpp</code>程序中写汇编代码。在汇编程序代码中经常可以引用<code>Cpp</code>的变量，这意味着可以方便地和<code>Cpp</code>代码通信，且限定汇编代码只是用于必要的高效调整，或使用特殊的处理器指令。编写汇编语言时所必须使用的严格语法是依赖于编译器的，在编译器的文档中可以发现有关语法。</p>
<h2 id="显式运算符"><a href="#显式运算符" class="headerlink" title="显式运算符"></a>显式运算符</h2><p>这是用于位运算符和逻辑运算符的关键字。没有<code>&amp;</code>、<code>1</code>、<code>^</code>这些键盘字符的非美国程序员被迫使用<code>C</code>的令人讨厌的三个图形字符(trigraph)，这使得不但在输入字符的时候令人烦恼，而且在阅读时也含义模糊。在<code>Cpp</code>中用附加的关键字来修补这种情况。</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">含 义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">and</td>
<td align="center">&amp;&amp;(逻辑与)</td>
</tr>
<tr>
<td align="center">or</td>
<td align="center">!!(逻辑或)</td>
</tr>
<tr>
<td align="center">not</td>
<td align="center">!(逻辑非)</td>
</tr>
<tr>
<td align="center">not_eq</td>
<td align="center">!&#x3D;(逻辑不等)</td>
</tr>
<tr>
<td align="center">bitand</td>
<td align="center">&amp;(位与)</td>
</tr>
<tr>
<td align="center">and_eq</td>
<td align="center">&amp;&#x3D;(位与-赋值)</td>
</tr>
<tr>
<td align="center">bitor</td>
<td align="center">|(位或)</td>
</tr>
<tr>
<td align="center">or_eq</td>
<td align="center">|&#x3D;(位或-赋值)</td>
</tr>
<tr>
<td align="center">xor</td>
<td align="center">^(位异或)</td>
</tr>
<tr>
<td align="center">xor_eq</td>
<td align="center">^&#x3D;(位异或-赋值)</td>
</tr>
<tr>
<td align="center">compl</td>
<td align="center">~(补)</td>
</tr>
</tbody></table>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章相当集中地浏览了<code>Cpp</code>语法的基本特征，许多特征是从<code>C</code>中继承过来的，同<code>C</code>是共有的(由此导致<code>Cpp</code>自夸与<code>C</code>向后兼容)。在这里虽然介绍了<code>Cpp</code>的某些特征，由于主要是针对熟悉编程的人，因此仅限于介绍<code>C</code>和<code>Cpp</code>的基本语法。</p>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left "
    
      href="/2024/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E8%AE%B2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8%E3%80%90%E5%8D%95%E9%A1%B9%E9%93%BE%E8%A1%A8%E3%80%91/"
      title="数据结构与算法——第三讲：单向链表"
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
      
        数据结构与算法——第三讲：单向链表
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/2024/09/10/2024-01-29-%5BCCpp%5D%E5%85%B3%E4%BA%8E%E5%BE%AA%E7%8E%AF/"
      title="[C/Cpp]关于循环"
     >

    <p class="title-text">
      
        [C/Cpp]关于循环
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>





    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2024 Mongxin Chan<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>

</footer>


  <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
  <script>
    mermaid.initialize({startOnLoad: true});
  </script>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn hide" onclick="topFunction()">
        <i class="fa-solid fa-angle-up"></i>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.classList.remove('hide')
        } else {
            btn.classList.add('hide')
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
</body>
</html>
