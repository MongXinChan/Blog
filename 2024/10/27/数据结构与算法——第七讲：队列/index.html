<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="true" > 
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  

  
  <title>数据结构与算法——第七讲： | MongXin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="preload" href="/css/fonts/Roboto-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
  <link rel="preload" href="/css/fonts/Roboto-Bold.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <meta name="description" content="前言我们既然有了一种先进后出的数据结构，那存不存在一种数据结构类型可以出列后进后出的情况呢？答案是显然的，数据结构是为了解决生活中的抽象问题，而银行排队，早茶叫号等都是一种排队，我们把这种先进先出的数据结构类型称之为队列 [TOC] 队列​	队列是一种特殊的线性表，从逻辑结构上看，队列仍然是线性表的一种，其特殊性主要体现在其基本运算有着特殊的限定。实际应用中有很多先到先得的问题，需要按先后顺序取解">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法——第七讲：">
<meta property="og:url" content="http://example.com/2024/10/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%83%E8%AE%B2%EF%BC%9A%E9%98%9F%E5%88%97/index.html">
<meta property="og:site_name" content="MongXin&#39;s Blog">
<meta property="og:description" content="前言我们既然有了一种先进后出的数据结构，那存不存在一种数据结构类型可以出列后进后出的情况呢？答案是显然的，数据结构是为了解决生活中的抽象问题，而银行排队，早茶叫号等都是一种排队，我们把这种先进先出的数据结构类型称之为队列 [TOC] 队列​	队列是一种特殊的线性表，从逻辑结构上看，队列仍然是线性表的一种，其特殊性主要体现在其基本运算有着特殊的限定。实际应用中有很多先到先得的问题，需要按先后顺序取解">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="d:\Hexo\blog\source\_posts\DataStructure\6-%E9%98%9F%E5%88%971.png">
<meta property="og:image" content="d:\Hexo\blog\source\_posts\DataStructure\6-%E9%98%9F%E5%88%972.png">
<meta property="og:image" content="d:\Hexo\blog\source\_posts\DataStructure\6-%E9%98%9F%E5%88%973.png">
<meta property="og:image" content="d:\Hexo\blog\source\_posts\DataStructure\6-%E9%98%9F%E5%88%974.png">
<meta property="og:image" content="d:\Hexo\blog\source\_posts\DataStructure\6-%E9%98%9F%E5%88%975.png">
<meta property="og:image" content="d:\Hexo\blog\source\_posts\DataStructure\6-%E9%98%9F%E5%88%976.png">
<meta property="og:image" content="d:\Hexo\blog\source\_posts\DataStructure\6-%E9%98%9F%E5%88%977.png">
<meta property="og:image" content="d:\Hexo\blog\source\_posts\DataStructure\6-%E9%98%9F%E5%88%978.png">
<meta property="og:image" content="d:\Hexo\blog\source\_posts\DataStructure\6-%E9%98%9F%E5%88%979.png">
<meta property="og:image" content="d:\Hexo\blog\source\_posts\DataStructure\6-%E9%98%9F%E5%88%9710.png">
<meta property="article:published_time" content="2024-10-27T08:52:28.209Z">
<meta property="article:modified_time" content="2024-11-06T03:27:29.517Z">
<meta property="article:author" content="MongXin">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:\Hexo\blog\source\_posts\DataStructure\6-%E9%98%9F%E5%88%971.png">
  
    <link rel="alternate" href="/atom.xml" title="MongXin's Blog" type="application/atom+xml">
  
  
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-192.png" sizes="192x192">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-192.png" sizes="192x192">
    <link rel="stylesheet" href="blog\node_modules\Typro-theme-YuanShan-master\assets\yuan-shan.css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>
  
  
    
<div id="banner" class="">
  <img src="/images/Banner.jpg" itemprop="image">
  <div id="banner-dim"></div>
</div>
 
   
  <div id="main-grid" class="  ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>MongXin's Blog </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">首页</a>
    
      <a class="main-nav-link" href="/archives">归档</a>
    
      <a class="main-nav-link" href="/music">音乐</a>
    
      <a class="main-nav-link" href="/movie">电影</a>
    
      <a class="main-nav-link" href="/notes">随笔</a>
    
      <a class="main-nav-link" href="/linking">友链</a>
    
      <a class="main-nav-link" href="/about">关于</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="light-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M438.5-829.913v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-829.913Zm0 747.826v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-82.087ZM877.913-438.5h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537t29.476-12.174h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T877.913-438.5Zm-747.826 0h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T82.087-521.5h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T130.087-438.5Zm660.174-290.87-34.239 32q-12.913 12.674-29.565 12.174-16.653-.5-29.327-13.174-12.674-12.673-12.554-28.826.12-16.152 12.794-28.826l33-35q12.913-12.674 30.454-12.674t30.163 12.847q12.709 12.846 12.328 30.826-.38 17.98-13.054 30.653ZM262.63-203.978l-32 34q-12.913 12.674-30.454 12.674t-30.163-12.847q-12.709-12.846-12.328-30.826.38-17.98 13.054-30.653l33.239-31q12.913-12.674 29.565-12.174 16.653.5 29.327 13.174 12.674 12.673 12.554 28.826-.12 16.152-12.794 28.826Zm466.74 33.239-32-33.239q-12.674-12.913-12.174-29.565.5-16.653 13.174-29.327 12.673-12.674 28.826-13.054 16.152-.38 28.826 12.294l35 33q12.674 12.913 12.674 30.454t-12.847 30.163q-12.846 12.709-30.826 12.328-17.98-.38-30.653-13.054ZM203.978-697.37l-34-33q-12.674-12.913-13.174-29.945-.5-17.033 12.174-29.707t31.326-13.293q18.653-.62 31.326 13.054l32 34.239q11.674 12.913 11.174 29.565-.5 16.653-13.174 29.327-12.673 12.674-28.826 12.554-16.152-.12-28.826-12.794ZM480-240q-100 0-170-70t-70-170q0-100 70-170t170-70q100 0 170 70t70 170q0 100-70 170t-170 70Zm-.247-82q65.703 0 111.475-46.272Q637-414.544 637-480.247t-45.525-111.228Q545.95-637 480.247-637t-111.475 45.525Q323-545.95 323-480.247t45.525 111.975Q414.05-322 479.753-322ZM481-481Z"/></svg></span>
      <span class="dark-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M480.239-116.413q-152.63 0-258.228-105.478Q116.413-327.37 116.413-480q0-130.935 77.739-227.435t206.304-125.043q43.022-9.631 63.87 10.869t3.478 62.805q-8.891 22.043-14.315 44.463-5.424 22.42-5.424 46.689 0 91.694 64.326 155.879 64.325 64.186 156.218 64.186 24.369 0 46.978-4.946 22.609-4.945 44.413-14.076 42.826-17.369 62.967 1.142 20.142 18.511 10.511 61.054Q807.174-280 712.63-198.206q-94.543 81.793-232.391 81.793Zm0-95q79.783 0 143.337-40.217 63.554-40.218 95.793-108.283-15.608 4.044-31.097 5.326-15.49 1.283-31.859.805-123.706-4.066-210.777-90.539-87.071-86.473-91.614-212.092-.24-16.369.923-31.978 1.164-15.609 5.446-30.978-67.826 32.478-108.282 96.152Q211.652-559.543 211.652-480q0 111.929 78.329 190.258 78.329 78.329 190.258 78.329ZM466.13-465.891Z"/></svg></span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/atom.xml" title="RSS 订阅">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M198-120q-25.846 0-44.23-18.384-18.384-18.385-18.384-44.23 0-25.846 18.384-44.23 18.384-18.385 44.23-18.385 25.846 0 44.23 18.385 18.384 18.384 18.384 44.23 0 25.845-18.384 44.23Q223.846-120 198-120Zm538.385 0q-18.846 0-32.923-13.769-14.076-13.769-15.922-33.23-8.692-100.616-51.077-188.654-42.385-88.039-109.885-155.539-67.5-67.501-155.539-109.885Q283-663.462 182.385-672.154q-19.461-1.846-33.23-16.23-13.769-14.385-13.769-33.846t14.076-32.922q14.077-13.461 32.923-12.23 120.076 8.692 226.038 58.768 105.961 50.077 185.73 129.846 79.769 79.769 129.846 185.731 50.077 105.961 58.769 226.038 1.231 18.846-12.538 32.922Q756.461-120 736.385-120Zm-252 0q-18.231 0-32.423-13.461t-18.653-33.538Q418.155-264.23 348.886-333.5q-69.27-69.27-166.501-84.423-20.077-4.462-33.538-18.961-13.461-14.5-13.461-33.346 0-19.076 13.884-33.23 13.884-14.153 33.115-10.922 136.769 15.384 234.384 112.999 97.615 97.615 112.999 234.384 3.231 19.23-10.538 33.115Q505.461-120 484.385-120Z"/></svg>
      </a>
    
    <div id="nav-menu-btn" class="nav-icon">
      <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M177.37-252.282q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Zm0-186.218q-17.453 0-29.477-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T177.37-521.5h605.26q17.453 0 29.477 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T782.63-438.5H177.37Zm0-186.217q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Z"/></svg>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">首页</a>
    
      <a class="nav-dropdown-link" href="/archives">归档</a>
    
      <a class="nav-dropdown-link" href="/music">音乐</a>
    
      <a class="nav-dropdown-link" href="/movie">电影</a>
    
      <a class="nav-dropdown-link" href="/notes">随笔</a>
    
      <a class="nav-dropdown-link" href="/linking">友链</a>
    
      <a class="nav-dropdown-link" href="/about">关于</a>
    
    
      <a class="nav-dropdown-link" href="/atom.xml" title="RSS 订阅">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=/%5Bobject%20Object%5D></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">Mongxin Chan </div>
      <div class="dot"></div>
      <div class="subtitle">这里就是罗德岛，要跳就在这里跳 </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://steamcommunity.com/id/MongXin_Chan" title="Steam"><i class="fa-brands fa-steam"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/MongXinChan" title="GitHub"><i class="fa-brands fa-github"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      


  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">分类</h3>
      <div class="category-box">
            <a class="category-link" href="/categories/%E8%AF%AD%E6%B3%95/">
                语法
                <div class="category-count">5</div>
            </a>
        
            <a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                数据结构
                <div class="category-count">7</div>
            </a>
        
            <a class="category-link" href="/categories/%E7%AB%9E%E8%B5%9B/">
                竞赛
                <div class="category-count">1</div>
            </a>
        </div>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">标签</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/C-Cpp/" rel="tag">C&#x2F;Cpp</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E4%BF%A1%E6%81%AF%E5%AD%A6/" rel="tag">信息学</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%AB%9E%E8%B5%9B/" rel="tag">竞赛</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91/" rel="tag">运行逻辑</a></li></ul>
    </div>
  </div>


    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       


<article id="post-数据结构与算法——第七讲：队列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        数据结构与算法——第七讲：
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2024-10-27T08:52:28.209Z" itemprop="datePublished">2024-10-27</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
  <a class="meta-cate-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            4.8k 词 
          </div>
        </div>
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们既然有了一种先进后出的数据结构，那存不存在一种数据结构类型可以出列后进后出的情况呢？答案是显然的，数据结构是为了解决生活中的抽象问题，而银行排队，早茶叫号等都是一种排队，我们把这种先进先出的数据结构类型称之为队列</p>
<p>[TOC]</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>​	队列是一种特殊的线性表，从逻辑结构上看，队列仍然是线性表的一种，其特殊性主要体现在其基本运算有着特殊的限定。实际应用中有很多先到先得的问题，需要按先后顺序取解决，比如排队购物，食堂排队取餐等，计算机解决这类问题需要用到队列来解决。</p>
<p>​	队列限定了线性表中的数据元素的插入和删除操作必须分别在线性表的两端进行，访问次序是先进先出。</p>
<h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><p>​	队列是一种特殊的线性表，其特殊性体现在对数据元素的插入和删除操作的限定。</p>
<p>​	队列的特点是先进先出（First In First Out，FIFO），即第一个进入队列的数据元素将第一个被删除。</p>
<p>​	<strong>队列的插入操作称为入队，队列的删除操作称为出队。队列的插入操作只能在队尾进行，队列的删除操作只能在队首进行。</strong></p>
<p>​	$a_0$为最先进入队列的数据元素，也将最先被访问，最先出队列，而$a_{n-1}$为最后进入的数据元素，也将最后被访问，最后出队列。</p>
<p>​	队列可以用于许多问题的求解，比如医院排队挂号、飞机检票进站、排队乘车、作业调度等，常用它来模拟求解。</p>
<hr>
<h3 id="队列的抽象类型"><a href="#队列的抽象类型" class="headerlink" title="队列的抽象类型"></a>队列的抽象类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">OperationInitQueue</span>(*Q):        初始化操作，建立一个空队列Q。</span><br><span class="line"></span><br><span class="line"><span class="built_in">DestroyQueue</span>(*Q):  若队列Q存在，则销毁它。</span><br><span class="line"></span><br><span class="line"><span class="built_in">ClearQueue</span>(*Q):      将队列Q清空。</span><br><span class="line"></span><br><span class="line"><span class="built_in">QueueEmpty</span>(Q):        若队列Q为空，返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br><span class="line"></span><br><span class="line"><span class="built_in">GetHead</span>(Q,  *e):      若队列Q存在且非空，用e返回队列Q的队头元素。</span><br><span class="line"></span><br><span class="line"><span class="built_in">EnQueue</span>(*Q,  e):      若队列Q存在，插入新元素e到队列Q中并成为队尾元素。</span><br><span class="line"></span><br><span class="line"><span class="built_in">DeQueue</span>(*Q,  *e):    删除队列Q中队头元素，并用e返回其值。</span><br><span class="line"></span><br><span class="line"><span class="built_in">QueueLength</span>(Q):      返回队列Q的元素个数endADT</span><br></pre></td></tr></table></figure>

<h3 id="队列的顺序存储结构"><a href="#队列的顺序存储结构" class="headerlink" title="队列的顺序存储结构"></a>队列的顺序存储结构</h3><p>线性表有顺序存储和链式存储，栈是线性表，具有这两种存储方式。同样’队列作为一种特殊的线性表，也同样存在这两种存储方式。我们先来看队列的顺序存储结构。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> strruct&#123;</span><br><span class="line">    ELemType data[MAXZSIZE];</span><br><span class="line">    <span class="type">int</span> front,rear;</span><br><span class="line">&#125;SqQueue</span><br></pre></td></tr></table></figure>

<p>顺序存储队列的主要不足在于它可能遇到<strong>“假溢出”</strong>的情况，即数组虽然还有空间，但由于队列的头尾指针的处理方式，导致无法继续添加元素。下面通过一个简单的图示来解释这个问题。</p>
<p>假设我们有一个固定大小为5的数组来存储队列：</p>
<img src="D:\Hexo\blog\source\_posts\DataStructure\6-队列1.png" alt="6-队列1" style="zoom:50%;" />

<p>队列的头指针（front）指向队列的第一个元素，尾指针（rear）指向队列最后一个元素的下一个位置。现在我们依次入队元素1, 2, 3, 4, 5：</p>
<img src="D:\Hexo\blog\source\_posts\DataStructure\6-队列2.png" alt="6-队列2" style="zoom:50%;" />

<p>此时队列已满，无法再添加新的元素。接下来我们出队元素1, 2：</p>
<img src="D:\Hexo\blog\source\_posts\DataStructure\6-队列3.png" alt="6-队列3" style="zoom:50%;" />

<p>现在，虽然数组的前两个位置是空的，但由于我们的头指针（front）已经移动到了索引1的位置，我们无法将新元素添加到索引0的位置。如果我们继续出队元素3, 4, 5：</p>
<img src="D:\Hexo\blog\source\_posts\DataStructure\6-队列4.png" alt="6-队列4" style="zoom:50%;" />

<p>此时，虽然数组看起来是空的，<strong>但实际上我们已经无法使用索引0和1的位置了，因为头指针（front）和尾指针（rear）的处理方式不允许我们在这两个位置插入新元素。</strong>这就是所谓的“假溢出”，即数组还有空间，但由于队列的实现方式，我们无法使用这些空间。</p>
<p>就像坐地铁，后一段的位子没了我们还应该往前看看。</p>
<p>所以循环队列应运而生。</p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p><strong>我们把队列的这种头尾相接的顺序存储结构称为循环队列。</strong>当队首指针<code>Q-&gt;front = MAXSIZE-1</code>后，再前进一个位置就自动到0，这可以利用除法取余运算（%）来实现。故而有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Q-&gt;front=Q-&gt;rear=<span class="number">0</span>;					<span class="comment">//初始化</span></span><br><span class="line">Q-&gt;front=(Q-&gt;front<span class="number">+1</span>)%MAXMIZE;		 <span class="comment">//队首指针+1</span></span><br><span class="line">Q-&gt;rear=(Q-&gt;rear<span class="number">+1</span>)%MAXMIZE;		 <span class="comment">//队尾指针+1</span></span><br><span class="line">(Q-&gt;rear-Q-&gt;front+MAXMIZE)%MAXMIZE;	  <span class="comment">//队列长度</span></span><br></pre></td></tr></table></figure>

<img src="D:\Hexo\blog\source\_posts\DataStructure\6-队列5.png" alt="6-队列5" style="zoom:50%;" />

<p>队列的初始化，<code>front</code>,<code>rear</code>都指向0;</p>
<img src="D:\Hexo\blog\source\_posts\DataStructure\6-队列6.png" alt="6-队列6" style="zoom:50%;" />

<p>1，2，3，4元素依次入队，还未溢出，跟普通的队列此时一样，<code>rear</code>指向下标为4的地方，标志着下一个元素进入队列时的位置。</p>
<img src="D:\Hexo\blog\source\_posts\DataStructure\6-队列7.png" alt="6-队列7" style="zoom:50%;" />

<p>1，2元素从队列中出队，<code>front</code>指针向后移动，指向下标为2的地方，标志着下一个出队的元素位置。</p>
<img src="D:\Hexo\blog\source\_posts\DataStructure\6-队列8.png" alt="6-队列8" style="zoom:50%;" />

<p>向队列中增加元素5，其从队尾加入，此时由于<code>MAXSIZE=5</code>，导致<code>rear+1&gt;5</code>可以被<code>MAXSIZE</code>取余，使得<code>rear=0</code>，指向的是下标为0的地方。</p>
<img src="D:\Hexo\blog\source\_posts\DataStructure\6-队列9.png" alt="6-队列9" style="zoom:50%;" />

<p><strong>如果这个时候我们再往队列加入元素6，7，会发现<code>rear</code>.<code>front</code>两个指针指向同一个地方，我们发现跟初始化队列的时候一样。</strong>&#x3D;&#x3D;这个时候我们难以判断到底是初始化了这个队列还是满的队列，所以我们这时候退而求其次，我们只要实现这个功能就行了，不要要求那么多了&#x3D;&#x3D;。</p>
<p>所以有：</p>
<img src="D:\Hexo\blog\source\_posts\DataStructure\6-队列10.png" alt="6-队列10" style="zoom:50%;" />

<p>牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是种较为普遍的做法，约定以“<strong>队头指针在队尾指针的下一位置作为队满的标志</strong>。</p>
<p>此时我们判断队满条件是为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Q-&gt;rear<span class="number">+1</span>)%MAXSIZE==Q-&gt;front</span><br></pre></td></tr></table></figure>

<p><strong>其他方法解决判定队满的方法</strong>:</p>
<p>方法1：类型中增设表示元素个数的数据成员。这样，队空的条件为 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q-&gt;size ==<span class="number">0</span>；</span><br></pre></td></tr></table></figure>

<p>队满的条件为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q-&gt;size == Maxsize</span><br></pre></td></tr></table></figure>

<p>这两种情况都有 <code>Q-&gt;front == Q-&gt;rear</code><br>方法2：类型中增设tag 数据成员，以区分是队满还是队空。</p>
<p>tag 等于0时，若因删除导致 Q-&gt;front &#x3D;&#x3D; Q-&gt;rear ，则为队空；</p>
<p>tag 等于 1 时，若因插入导致 Q -&gt;front &#x3D;&#x3D; Q-&gt;rear ，则为队满。</p>
<p><strong>由于篇幅问题，我会另外开一篇这两种方法如何实现入队出队。</strong></p>
<h4 id="队列顺序存储的实现"><a href="#队列顺序存储的实现" class="headerlink" title="队列顺序存储的实现"></a>队列顺序存储的实现</h4><p>存储结构代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    QElemType data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>

<p>循环队列初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue *Q)</span></span>&#123;</span><br><span class="line">    Q-&gt;front=<span class="number">0</span>;</span><br><span class="line">    Q-&gt;rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>K;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求其长度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear-Q.front+MAXSIZE)%NAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环队列入队：</p>
<ol>
<li>检查队列是否已满。如果队列已满，入队操作失败。</li>
<li>将新元素添加到队尾指针（rear）所指的位置。</li>
<li>更新队尾指针，使其指向下一个可用的位置。如果队尾指针已经到达队列的末尾，将其重置为队列的起始位置。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue *Q,QElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q-&gt;rear<span class="number">+1</span>)%MAXSIZE==Q-&gt;front)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q-&gt;data[Q-&gt;rear]=e;</span><br><span class="line">    Q-&gt;rear=(Q-&gt;rear<span class="number">+1</span>)%MAXSIZE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>K;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出队：</p>
<ol>
<li>检查队列是否为空。如果队列为空，出队操作失败。</li>
<li>从队头指针（front）所指的位置移除元素。</li>
<li>更新队头指针，使其指向下一个元素的位置。如果队头指针已经到达队列的末尾，将其重置为队列的起始位置。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue *Q,QElemType *e)</span></span>&#123;<span class="comment">//QElemType这里多了一个*</span></span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front==Q-&gt;rare)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e=Q-&gt;data[Q-&gt;front];</span><br><span class="line">    Q-&gt;front=(Q-&gt;front<span class="number">+1</span>)%MAXSIZE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>K;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="队列链式存储的实现"><a href="#队列链式存储的实现" class="headerlink" title="队列链式存储的实现"></a>队列链式存储的实现</h4><p>存储结构代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span>&#123;</span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">QNode</span> *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    QueuePtr front,rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>

<p>入队代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue *Q, QElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 入队操作，将元素 e 插入到队列 Q 中</span></span><br><span class="line">    QueuePtr s = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line">    <span class="comment">// 为新节点分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (!s)</span><br><span class="line">        <span class="comment">// 如果内存分配失败，退出程序</span></span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    <span class="comment">// 新节点的数据域赋值为 e</span></span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 新节点的指针域置空</span></span><br><span class="line">    Q-&gt;rear-&gt;next = s;</span><br><span class="line">    <span class="comment">// 将新节点插入到队列的尾部</span></span><br><span class="line">    Q-&gt;rear = s;</span><br><span class="line">    <span class="comment">// 更新队列的尾指针</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="comment">// 返回操作成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>出队代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue *Q, QElemType *e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 出队操作，从队列 Q 中移除一个元素，并将其存储在 e 中</span></span><br><span class="line">    QueuePtr p;</span><br><span class="line">    <span class="comment">// 定义一个指向队列节点的指针 p</span></span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)</span><br><span class="line">        <span class="comment">// 如果队列的头指针和尾指针相等，说明队列为空</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="comment">// 返回错误状态</span></span><br><span class="line">    p = Q-&gt;front-&gt;next;</span><br><span class="line">    <span class="comment">// 将 p 指向队列的第一个节点</span></span><br><span class="line">    *e = p-&gt;data;</span><br><span class="line">    <span class="comment">// 将 p 节点的数据存储在 e 中</span></span><br><span class="line">    Q-&gt;front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="comment">// 将队列头节点的下一个指针指向 p 节点的下一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;rear == p)</span><br><span class="line">        <span class="comment">// 如果 p 节点是队列的尾节点</span></span><br><span class="line">        Q-&gt;rear = Q-&gt;front;</span><br><span class="line">    <span class="comment">// 将队列的尾指针重置为队列的头指针</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="comment">// 释放 p 节点所占用的内存空间</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="comment">// 返回操作成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="队列案例"><a href="#队列案例" class="headerlink" title="队列案例"></a>队列案例</h3><p>生产者-消费者问题<br>在生产者-消费者问题中，生产者负责生产数据并将其放入队列，而消费者负责从队列中取出数据并进行处理。这个问题可以通过使用队列来实现线程间的通信和同步。</p>
<p>在上述代码中，我们定义了一个循环队列 Queue，并实现了入队 EnQueue 和出队 DeQueue 操作。在实际应用中，我们可以根据具体需求扩展队列的功能，例如增加队列长度的动态调整、支持优先级队列等。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>队列是一种特殊的线性表，<strong>它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作</strong>。队列的操作遵循先进先出（FIFO）的原则，即第一个进入队列的数据元素将第一个被删除。</p>
<p>队列的抽象数据类型定义了一系列操作，包括<u>初始化队列、销毁队列、清空队列、判断队列是否为空、获取队列的队头元素、入队操作和出队操作</u>等。</p>
<p>队列的顺序存储结构使用数组来实现，通过front和rear指针来指示队列的头和尾。在顺序存储队列中，可能会出现“假溢出”的情况，即数组虽然还有空间，但由于队列的头尾指针的处理方式，导致无法继续添加元素。</p>
<p>为了解决“假溢出”问题，可以使用循环队列的方式来实现队列的顺序存储。<strong>循环队列通过将数组的首尾相连，使得队列的头尾指针可以在数组的两端循环移动，从而充分利用数组的空间。</strong></p>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left "
    
      href="/2024/10/29/%E5%9C%A8C%E4%B8%AD%E7%9A%84CPP%E2%80%94%E2%80%94String/"
      title=""
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
      
        (No Title)
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/2024/10/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%94%E8%AE%B2%EF%BC%9A%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"
      title="数据结构与算法——第五讲："
     >

    <p class="title-text">
      
        数据结构与算法——第五讲：
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>





    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2024 Mongxin Chan<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>

</footer>


  <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
  <script>
    mermaid.initialize({startOnLoad: true});
  </script>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn hide" onclick="topFunction()">
        <i class="fa-solid fa-angle-up"></i>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.classList.remove('hide')
        } else {
            btn.classList.add('hide')
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
</body>
</html>
